{"version":3,"file":"js/node_modules_add_index_js_5c743c5c.js","mappings":";;;;;;;;AAAA;AACA;;AAEA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACvB;AACA;AACA,OAAO,EAMJ;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,MAAM;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU,MAAM;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://remote-app/./node_modules/add/index.js"],"sourcesContent":["(function (root, factory) {\n  \"use strict\";\n\n  // AMD\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  // CommonJS\n  else if (typeof exports === 'object') {\n    module.exports = factory();\n  }\n  // Browser\n  else {\n    root.add = factory();\n  }\n})(this, function () {\n  \"use strict\";\n\n  // The minimum machine rounding error\n  var Epsilon = Math.pow(2, -53)\n    , EpsilonReciprocal = (1 / Epsilon)\n      /// The smallest positive number that can be represented\n    , Eta = Math.pow(2, -1074)\n      // limitB is a constant used in the transform function\n    , limitB = 0.5 * EpsilonReciprocal * Eta\n\n  /**\n  * S. M. RUMP, T. OGITA AND S. OISHI\n  * http://www.ti3.tu-harburg.de/paper/rump/RuOgOi07I.pdf\n  */\n\n  // Page 8\n  // x is result, y is error\n  // third is so the array is allocated for 4 spaces\n  // it speeds up transform\n  function fastTwoSum(a, b) {\n    var x = a + b\n      , q = x - a\n      , y = b - q\n\n    return [x, y, null]\n  }\n\n  // Page 12\n  // p = q + p'\n  // sigma is a power of 2 greater than or equal to |p|\n  function extractScalar(sigma, p) {\n    var q = (sigma + p) - sigma\n      , pPrime = p - q\n\n    return [q, pPrime]\n  }\n\n  // Page 12\n  function extractVector(sigma, p) {\n    var tau = 0.0\n      , extracted\n      , i = 0\n      , ii = p.length\n      , pPrime = new Array(ii)\n\n    for(; i<ii; ++i) {\n      extracted = extractScalar(sigma, p[i])\n      pPrime[i] = extracted[1]\n      tau += extracted[0]\n    }\n\n    return [tau, pPrime]\n  }\n\n  // Finds the immediate power of 2 that is larger than p\n  //// in a fast way\n  function nextPowerTwo (p) {\n    var q = EpsilonReciprocal * p\n      , L = Math.abs((q + p) - q)\n\n    if(L === 0)\n      return Math.abs(p)\n\n    return L\n  }\n\n  // Helper, gets the maximum of the absolute values of an array\n  function maxAbs(arr) {\n    var i = 0\n      , ii = arr.length\n      , best = -1\n\n    for(; i<ii; ++i) {\n      if(Math.abs(arr[i]) > best) {\n        best = arr[i]\n      }\n    }\n\n    return best\n  }\n\n  function transform (p) {\n    var mu = maxAbs(p)\n      , M\n      , sigmaPrime\n      , tPrime\n      , t\n      , tau\n      , sigma\n      , extracted\n      , res\n\n        // Not part of the original paper, here for optimization\n      , temp\n      , bigPow\n      , limitA\n      , twoToTheM\n\n    if(mu === 0) {\n      return [0, 0, p, 0]\n    }\n\n    M = nextPowerTwo(p.length + 2)\n    twoToTheM = Math.pow(2, M)\n    bigPow = 2 * twoToTheM // equiv to Math.pow(2, 2 * M), faster\n    sigmaPrime = twoToTheM * nextPowerTwo(mu)\n    tPrime = 0\n\n    do {\n      t = tPrime\n      sigma = sigmaPrime\n      extracted = extractVector(sigma, p)\n      tau = extracted[0]\n      tPrime = t + tau\n      p = extracted[1]\n\n      if(tPrime === 0) {\n        return transform(p)\n      }\n\n      temp = Epsilon * sigma\n      sigmaPrime = twoToTheM * temp\n      limitA = bigPow * temp\n    }\n    while( Math.abs(tPrime) < limitA && sigma > limitB )\n\n    // res already allocated for 4\n    res = fastTwoSum(t, tau)\n    res[2] = p\n\n    return res\n  }\n\n  function dumbSum(p) {\n    var i, ii, sum = 0.0\n    for(i=0, ii=p.length; i<ii; ++i) {\n      sum += p[i]\n    }\n    return sum\n  }\n\n  function accSum(p) {\n\n    // Zero length array, or all values are zeros\n    if(p.length === 0 || maxAbs(p) === 0) {\n      return 0\n    }\n\n    var tfmd = transform(p)\n\n    return tfmd[0] + (tfmd[1] +dumbSum(tfmd[2]))\n  }\n\n\n  // exports\n  accSum.dumbSum = dumbSum;\n  accSum.fastTwoSum = fastTwoSum;\n  accSum.nextPowerTwo = nextPowerTwo;\n  return accSum;\n});\n\n"],"names":[],"sourceRoot":""}